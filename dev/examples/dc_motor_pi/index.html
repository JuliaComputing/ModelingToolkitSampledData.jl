<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Controlled DC motor · ModelingToolkitSampledData.jl</title><meta name="title" content="Controlled DC motor · ModelingToolkitSampledData.jl"/><meta property="og:title" content="Controlled DC motor · ModelingToolkitSampledData.jl"/><meta property="twitter:title" content="Controlled DC motor · ModelingToolkitSampledData.jl"/><meta name="description" content="Documentation for ModelingToolkitSampledData.jl."/><meta property="og:description" content="Documentation for ModelingToolkitSampledData.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkitSampledData.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkitSampledData.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/SampledData/">Getting started with Sampled-Data Systems</a></li><li><a class="tocitem" href="../../tutorials/noise/">Noise and measurement corruption</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Controlled DC motor</a><ul class="internal"><li><a class="tocitem" href="#Modeling-and-simulation"><span>Modeling and simulation</span></a></li><li><a class="tocitem" href="#Discrete-time-controller"><span>Discrete-time controller</span></a></li></ul></li><li><a class="tocitem" href="../onoffcontroller/">On-off controller</a></li><li><a class="tocitem" href="../sliding_mode_control/">Sliding-mode control</a></li></ul></li><li><a class="tocitem" href="../../blocks/">Library API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Controlled DC motor</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Controlled DC motor</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/ModelingToolkitSampledData.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="DC-Motor-with-PI-controller"><a class="docs-heading-anchor" href="#DC-Motor-with-PI-controller">DC Motor with PI-controller</a><a id="DC-Motor-with-PI-controller-1"></a><a class="docs-heading-anchor-permalink" href="#DC-Motor-with-PI-controller" title="Permalink"></a></h1><p>In this example, a PI-controller is set up for speed control of a DC-motor. An equivalent circuit diagram is depicted below.</p><p><img src="https://user-images.githubusercontent.com/50108075/196108356-0e8605e3-61a9-4006-8559-786252e55928.png" alt="DC-motor"/></p><p>First, a continuous-time velocity controller will be used, we then change the controller to be implemented in discrete-time in <a href="#Discrete-time-controller">Discrete-time controller</a>. Finally, we add an outer position controller in <a href="#Adding-a-slower-outer-position-loop">Adding a slower outer position loop</a>.</p><h2 id="Modeling-and-simulation"><a class="docs-heading-anchor" href="#Modeling-and-simulation">Modeling and simulation</a><a id="Modeling-and-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-and-simulation" title="Permalink"></a></h2><p>The electrical part consists of a resistance and inductance. The coupling between the electrical and rotational domain is done via an electro-motive force (EMF) component. The voltage across the EMF is proportional to the angular velocity and the current is proportional to the torque. On the mechanical side, viscous friction in, e.g., a bearing and the inertia of the shaft is modelled.</p><p>A PI-controller with anti-windup measure should be used as a speed controller. A simulation is performed to verify the tracking performance of the controller and the disturbance rejection capabilities.</p><p>First, the needed packages are imported and the parameters of the model defined.</p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t
using ModelingToolkitStandardLibrary.Electrical
using ModelingToolkitStandardLibrary.Mechanical.Rotational
using ModelingToolkitStandardLibrary.Blocks
using OrdinaryDiffEq
using Plots

R = 0.5 # [Ohm] armature resistance
L = 4.5e-3 # [H] armature inductance
k = 0.5 # [N.m/A] motor constant
J = 0.02 # [kg.m²] inertia
f = 0.01 # [N.m.s/rad] friction factor
tau_L_step = -0.3 # [N.m] amplitude of the load torque step</code></pre><p>The actual model can now be composed.</p><pre><code class="language-julia hljs">@named ground = Ground()
@named source = Voltage()
@named ref = Blocks.Step(height = 1, start_time = 0)
@named pi_controller = Blocks.LimPI(k = 1.1, T = 0.035, u_max = 10, Ta = 0.035)
@named feedback = Blocks.Feedback()
@named R1 = Resistor(R = R)
@named L1 = Inductor(L = L)
@named emf = EMF(k = k)
@named fixed = Fixed()
@named load = Torque()
@named load_step = Blocks.Step(height = tau_L_step, start_time = 1.3)
@named inertia = Inertia(J = J)
@named friction = Damper(d = f)
@named speed_sensor = SpeedSensor()

connections = [connect(fixed.flange, emf.support, friction.flange_b)
               connect(emf.flange, friction.flange_a, inertia.flange_a)
               connect(inertia.flange_b, load.flange)
               connect(inertia.flange_b, speed_sensor.flange)
               connect(load_step.output, load.tau)
               connect(ref.output, feedback.input1)
               connect(speed_sensor.w, feedback.input2)
               connect(feedback.output, pi_controller.err_input)
               connect(pi_controller.ctr_output, source.V)
               connect(source.p, R1.p)
               connect(R1.n, L1.p)
               connect(L1.n, emf.p)
               connect(emf.n, source.n, ground.g)]

@named model = ODESystem(connections, t,
    systems = [
        ground,
        ref,
        pi_controller,
        feedback,
        source,
        R1,
        L1,
        emf,
        fixed,
        load,
        load_step,
        inertia,
        friction,
        speed_sensor
    ])
model = complete(model)</code></pre><p>Now the model can be simulated. Typical rotational mechanical systems are described via <code>DAE</code> (differential algebraic equations), however in this case, ModelingToolkit can simplify the model enough so that it can be represented as a system of <code>ODEs</code> (ordinary differential equations).</p><pre><code class="language-julia hljs">sys = structural_simplify(model)
prob = ODEProblem(sys, unknowns(sys) .=&gt; 0.0, (0, 2.0))
sol = solve(prob, Tsit5())

p1 = Plots.plot(sol.t, sol[inertia.w], ylabel = &quot;Angular Vel. in rad/s&quot;,
    label = &quot;Measurement&quot;, title = &quot;DC Motor with Speed Controller&quot;)
Plots.plot!(sol.t, sol[ref.output.u], label = &quot;Reference&quot;)
p2 = Plots.plot(sol.t, sol[load.tau.u], ylabel = &quot;Disturbance in Nm&quot;, label = &quot;&quot;)
Plots.plot(p1, p2, layout = (2, 1))</code></pre><img src="bfe4842e.svg" alt="Example block output"/><h2 id="Discrete-time-controller"><a class="docs-heading-anchor" href="#Discrete-time-controller">Discrete-time controller</a><a id="Discrete-time-controller-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-time-controller" title="Permalink"></a></h2><p>Until now, we have modeled both the physical part of the system, the DC motor, and the control systems, in continuous time. In practice, it is common to implement control systems on a computer operating at a fixed sample rate, i.e, in discrete time. A system containing both continuous-time parts and discrete-time parts is often referred to as a &quot;sampled-data system&quot;, and the ModelingToolkit standard library together with ModelingToolkitSampledData.jl contain several components to model such systems.</p><p>Below, we re-model the system, this time with a discrete-time controller: <a href="../../blocks/#ModelingToolkitSampledData.DiscretePIDStandard"><code>DiscretePIDStandard</code></a>. To interface between the continuous and discrete parts of the model, we make use of a <a href="../../blocks/#ModelingToolkitSampledData.Sampler"><code>Sampler</code></a> and <a href="../../blocks/#ModelingToolkitSampledData.ZeroOrderHold"><code>ZeroOrderHold</code></a> blocks. Apart from the three aforementioned components, the model is the same as before.</p><pre><code class="language-julia hljs">using ModelingToolkitSampledData
using JuliaSimCompiler

z = ShiftIndex()
@mtkmodel DiscreteClosedLoop begin
    @structural_parameters begin
        use_ref = true
    end
    @components begin
        ground = Ground()
        source = Voltage()
        ref = Blocks.Step(height = 1, start_time = 0, smooth = false)
        sampler = Sampler(dt = 0.005)
        pi_controller = DiscretePIDStandard(
            K = 1, Ti = 0.035, u_max = 10, with_D = false)
        zoh = ZeroOrderHold()
        R1 = Resistor(R = R)
        L1 = Inductor(L = L)
        emf = EMF(k = k)
        fixed = Fixed()
        load = Torque()
        load_step = Blocks.Step(height = tau_L_step, start_time = 1.3)
        inertia = Inertia(J = J)
        friction = Damper(d = f)
        speed_sensor = SpeedSensor()
        angle_sensor = AngleSensor()
    end

    @equations begin
        connect(fixed.flange, emf.support, friction.flange_b)
        connect(emf.flange, friction.flange_a, inertia.flange_a)
        connect(inertia.flange_b, load.flange)
        connect(inertia.flange_b, speed_sensor.flange, angle_sensor.flange)
        connect(load_step.output, load.tau)
        if use_ref
            connect(ref.output, pi_controller.reference)
        end
        connect(speed_sensor.w, sampler.input)
        connect(sampler.output, pi_controller.measurement)
        connect(pi_controller.ctr_output, zoh.input)
        connect(zoh.output, source.V)
        connect(source.p, R1.p)
        connect(R1.n, L1.p)
        connect(L1.n, emf.p)
        connect(emf.n, source.n, ground.g)
    end
end

@named disc_model = DiscreteClosedLoop()
disc_model = complete(disc_model)
ssys = structural_simplify(IRSystem(disc_model)) # Conversion to an IRSystem from JuliaSimCompiler is required for sampled-data systems

disc_prob = ODEProblem(ssys, [unknowns(disc_model) .=&gt; 0.0; disc_model.pi_controller.I(z-1) =&gt; 0; disc_model.pi_controller.eI(z-1) =&gt; 0], (0, 2.0))
disc_sol = solve(disc_prob, Tsit5())

Plots.plot(sol.t, sol[inertia.w], ylabel = &quot;Angular Vel. in rad/s&quot;,
    label = &quot;Measurement (cont. controller)&quot;, title = &quot;DC Motor with Speed Controller&quot;)
Plots.plot!(disc_sol.t, disc_sol[inertia.w], ylabel = &quot;Angular Vel. in rad/s&quot;,
    label = &quot;Measurement (disc. controller)&quot;, title = &quot;DC Motor with Discrete-time Speed Controller&quot;, legend=:bottomleft, dpi=600)
lens!([1.2, 1.6], [0.75, 1.02], inset=(1, bbox(.6, .5, .3, .4))) # 1 is subplot index</code></pre><img src="27e65797.svg" alt="Example block output"/><p>In the plot above, we compare the result of the discrete-time control system to the continuous-time result from before. We see that with the chosen sample-interval of <code>dt=0.005</code> (provided to the <code>Sampler</code> block), we have a slight degradation in the control performance as a consequence of the discretization.</p><h3 id="Adding-a-slower-outer-position-loop"><a class="docs-heading-anchor" href="#Adding-a-slower-outer-position-loop">Adding a slower outer position loop</a><a id="Adding-a-slower-outer-position-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-slower-outer-position-loop" title="Permalink"></a></h3><p>Below, we add an outer control loop that controls the position of the motor by manipulating the reference to the inner speed controller. This is a common control strategy, often referred to as <em>cascade control</em>.</p><p><img src="https://help.juliahub.com/juliasimcontrol/dev/figs/cascade_pid.png" alt="block diagram of a cascade control loop"/></p><pre><code class="language-julia hljs">@mtkmodel Cascade begin
    @components begin
        inner = DiscreteClosedLoop(use_ref = false)
        sampler = Sampler(clock = Clock(0.005))
        # cc = ClockChanger(from = get_clock(sampler), to = get_clock(inner.sampler)) # Currently deactivated due to bug
        cc = Gain(k = 1)
        ref = Blocks.Ramp(height = 1, start_time = 0.05, duration = 0.85, smooth = false)
        ref_diff = DiscreteDerivative() # This will differentiate q_ref to q̇_ref
        add = Blocks.Add()      # The middle ∑ block in the diagram
        p_controller = DiscretePIDStandard(K = 20, with_D = false, with_I = false)
    end
    @parameters begin
        O = 0
    end
    begin
        from = get_clock(sampler)
        to = get_clock(inner.sampler)
    end
    @equations begin
        # cc.y(ShiftIndex(to)) ~ ClockChange(; from, to)(cc.u(ShiftIndex(from))) + O
        # cc.y ~ ClockChange(; from, to)(cc.u) + eps()^10
        # cc.y ~ cc.u
        connect(ref.output, p_controller.reference, ref_diff.input)
        connect(ref_diff.output, add.input1)
        connect(add.output, cc.input)
        connect(cc.output, inner.pi_controller.reference)
        connect(p_controller.ctr_output, add.input2)
        connect(inner.angle_sensor.phi, sampler.input)
        connect(sampler.output, p_controller.measurement)
    end
end

@named cascade = Cascade()
cascade = complete(cascade)
ssys = structural_simplify(IRSystem(cascade))
i = cascade.inner
cascade_prob = ODEProblem(ssys, [
    unknowns(cascade) .=&gt; 0.0;
    i.pi_controller.I(z-1) =&gt; 0;
    i.pi_controller.eI(z-1) =&gt; 0;
    cascade.p_controller.I(z-1) =&gt; 0;
    cascade.ref_diff.u(z-1) =&gt; 0.0;
    cascade.cc.u(z-1) =&gt; 0.0;
    ], (0, 2))
cascade_sol = solve(cascade_prob, Tsit5())
Plots.plot(cascade_sol, idxs = [i.inertia.phi, i.inertia.w, i.zoh.u])</code></pre><img src="92bdfb2b.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/noise/">« Noise and measurement corruption</a><a class="docs-footer-nextpage" href="../onoffcontroller/">On-off controller »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 17:04">Monday 23 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
