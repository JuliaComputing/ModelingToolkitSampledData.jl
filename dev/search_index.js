var documenterSearchIndex = {"docs":
[{"location":"tutorials/SampledData/#Clocks-and-Sampled-Data-Systems","page":"Getting started with Sampled-Data Systems","title":"Clocks and Sampled-Data Systems","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"A sampled-data system contains both continuous-time and discrete-time components, such as a continuous-time plant model and a discrete-time control system. ModelingToolkit supports the modeling and simulation of sampled-data systems by means of clocks.","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"danger: Experimental\nThe sampled-data interface in ModelingToolkit is currently experimental and at any time subject to breaking changes not respecting semantic versioning.","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"note: Negative shifts\nThe initial release of the sampled-data interface only supports negative shifts.","category":"page"},{"location":"tutorials/SampledData/#Clocks,-operators-and-difference-equations","page":"Getting started with Sampled-Data Systems","title":"Clocks, operators and difference equations","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"A clock can be seen as an event source, i.e., when the clock ticks, an event is generated. In response to the event the discrete-time logic is executed, for example, a control signal is computed. For basic modeling of sampled-data systems, the user does not have to interact with clocks explicitly, instead, the modeling is performed using the operators","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"ModelingToolkit.Sample\nModelingToolkit.Hold\nModelingToolkit.ShiftIndex\nor their corresponding components\nModelingToolkitSampledData.Sampler\nModelingToolkitSampledData.ZeroOrderHold","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"When a continuous-time variable x is sampled using xd = Sample(x, dt), the result is a discrete-time variable xd that is defined and updated whenever the clock ticks. xd is only defined when the clock ticks, which it does with an interval of dt. If dt is unspecified, the tick rate of the clock associated with xd is inferred from the context in which xd appears. Any variable taking part in the same equation as xd is inferred to belong to the same discrete partition as xd, i.e., belonging to the same clock. A system may contain multiple different discrete-time partitions, each with a unique clock. This allows for modeling of multi-rate systems and discrete-time processes located on different computers etc.","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"To make a discrete-time variable available to the continuous partition, the Hold operator is used. xc = Hold(xd) creates a continuous-time variable xc that is updated whenever the clock associated with xd ticks, and holds its value constant between ticks.","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"The operators Sample and Hold are thus providing the interface between continuous and discrete partitions.","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"The ShiftIndex operator is used to refer to past and future values of discrete-time variables. The example below illustrates its use, implementing the discrete-time system","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"x(k+1) = 05x(k) + u(k)\ny(k) = x(k)","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t\n@variables x(t) y(t) u(t)\ndt = 0.1                # Sample interval\nclock = Clock(dt)    # A periodic clock with tick rate dt\nk = ShiftIndex(clock)\n\neqs = [\n    x(k) ~ 0.5x(k - 1) + u(k - 1),\n    y ~ x\n]","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"A few things to note in this basic example:","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"The equation x(k+1) = 0.5x(k) + u(k) has been rewritten in terms of negative shifts since positive shifts are not yet supported.\nx and u are automatically inferred to be discrete-time variables, since they appear in an equation with a discrete-time ShiftIndex k.\ny is also automatically inferred to be a discrete-time-time variable, since it appears in an equation with another discrete-time variable x. x,u,y all belong to the same discrete-time partition, i.e., they are all updated at the same instantaneous point in time at which the clock ticks.\nThe equation y ~ x does not use any shift index, this is equivalent to y(k) ~ x(k), i.e., discrete-time variables without shift index are assumed to refer to the variable at the current time step.\nThe equation x(k) ~ 0.5x(k-1) + u(k-1) indicates how x is updated, i.e., what the value of x will be at the current time step in terms of the past value. The output y, is given by the value of x at the current time step, i.e., y(k) ~ x(k). If this logic was implemented in an imperative programming style, the logic would thus be","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"function discrete_step(x, u)\n    x = 0.5x + u # x is updated to a new value, i.e., x(k) is computed\n    y = x # y is assigned the current value of x, y(k) = x(k)\n    return x, y # The state x now refers to x at the current time step, x(k), and y equals x, y(k) = x(k)\nend","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"An alternative and equivalent way of writing the same system is","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"eqs = [\n    x(k + 1) ~ 0.5x(k) + u(k),\n    y(k) ~ x(k)\n]","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"but the use of positive time shifts is not yet supported. Instead, we shifted all indices by -1 above, resulting in exactly the same difference equations. However, the next system is not equivalent to the previous one:","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"eqs = [\n    x(k) ~ 0.5x(k - 1) + u(k),\n    y ~ x\n]","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"In this last example, u(k) refers to the input at the new time point k., this system is equivalent to","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"eqs = [\n    x(k+1) ~ 0.5x(k) + u(k+1),\n    y(k) ~ x(k)\n]","category":"page"},{"location":"tutorials/SampledData/#Higher-order-shifts","page":"Getting started with Sampled-Data Systems","title":"Higher-order shifts","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"The expression x(k-1) refers to the value of x at the previous clock tick. Similarly, x(k-2) refers to the value of x at the clock tick before that. In general, x(k-n) refers to the value of x at the nth clock tick before the current one. As an example, the Z-domain transfer function","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"H(z) = dfracb_2 z^2 + b_1 z + b_0a_2 z^2 + a_1 z + a_0","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"may thus be modeled as","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"@variables t y(t) [description = \"Output\"] u(t) [description = \"Input\"]\nk = ShiftIndex(Clock(dt))\neqs = [\n    a2 * y(k) + a1 * y(k - 1) + a0 * y(k - 2) ~ b2 * u(k) + b1 * u(k - 1) + b0 * u(k - 2)\n]","category":"page"},{"location":"tutorials/SampledData/#Initial-conditions","page":"Getting started with Sampled-Data Systems","title":"Initial conditions","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"The initial condition of discrete-time variables is defined using the ShiftIndex operator, for example","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"ODEProblem(model, [x(k-1) => 1.0], (0.0, 10.0))","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Note how the initial condition for discrete-time variables refer to the past, and not to the value at t=0 (at tspan[1] to be precise). The reason is that in order to perform the discrete-time state update x(k) = f(x(k-1) t_0), at the initial time t_0, we need x(k-1) and not x(k).","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"If higher-order shifts are present, the corresponding initial conditions must be specified, e.g., the presence of the equation","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"x(k) = x(k - 1) + x(k - 2)","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"requires specification of the initial condition for both x(k-1) and x(k-2).","category":"page"},{"location":"tutorials/SampledData/#Multiple-clocks","page":"Getting started with Sampled-Data Systems","title":"Multiple clocks","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Multi-rate systems are easy to model using multiple different clocks. The following set of equations is valid, and defines two different discrete-time partitions, each with its own clock:","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"yd1 ~ Sample(dt1)(y)\nud1 ~ kp * (Sample(dt1)(r) - yd1)\nyd2 ~ Sample(dt2)(y)\nud2 ~ kp * (Sample(dt2)(r) - yd2)","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"yd1 and ud1 belong to the same clock which ticks with an interval of dt1, while yd2 and ud2 belong to a different clock which ticks with an interval of dt2. The two clocks are not synchronized, i.e., they are not guaranteed to tick at the same point in time, even if one tick interval is a rational multiple of the other. Mechanisms for synchronization of clocks are not yet implemented.","category":"page"},{"location":"tutorials/SampledData/#Accessing-discrete-time-variables-in-the-solution","page":"Getting started with Sampled-Data Systems","title":"Accessing discrete-time variables in the solution","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Discrete-time variables can be accessed with the syntax","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"sol[var]","category":"page"},{"location":"tutorials/SampledData/#Implementing-generic-discrete-time-components","page":"Getting started with Sampled-Data Systems","title":"Implementing generic discrete-time components","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Discrete-time components can be implemented without specification of the clock or sample interval. To do this, the operator SampleTime() is used, it returns the sample-time interval of the associated clock. See the library of components for usage example, or this simplified example component:","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"@mtkmodel DiscreteDerivative begin\n    @extend u, y = siso = SISO()\n    @parameters begin\n        k = 1, [description = \"Gain\"]\n    end\n    @structural_parameters begin\n        Ts = SampleTime()\n        z = ShiftIndex()\n    end\n    @equations begin\n        y(z) ~ k * (u(z) - u(z - 1)) / Ts # Ts will get the value of the associated clock, determined by clock inference.\n    end\nend","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"In this component, we use two structural parameters, one for the sample time and one for the shift index. By letting the sample time be a structural parameter with a default given by SampleTime(), the default behavior is to inherit the sample time based on the connection context (clock partition) of the component. The sample time can still be manually set in case there is no other point at which to infer the sample time, or if the user for some other reason want to override the sample time. The shift index is also a structural parameter with a default. This default leaves the clock unspecified, indicating that the clock should be inherited based on the connection context (clock partition). If the user provides a shift index with a clock specified, other components may inherit their clock from this component. The operator SampleTime() will in all cases return the sample time of the associated clock, no matter if this clock is explicitly specified by the user or inherited from the connection context.","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"In order to make components maximally generic, it is often advisable to avoid including operators like Sample and Hold at the inputs and outputs of a component, and instead let the user manually insert these operators where required. Larger components that model complete sampled-data systems may of course contain such operators internally. ","category":"page"},{"location":"tutorials/SampledData/#Linearization-of-sampled-data-systems","page":"Getting started with Sampled-Data Systems","title":"Linearization of sampled-data systems","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Linearization of discrete-time and sampled-data systems using the tools described at Linearization of ModelingToolkit models is not supported at the moment. 😦 ","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Linearization through frequency-response analysis (FRA) is provided in JuliaSimControl. FRA amounts to simulating a system with wide-spectrum inputs and computing the linear small-signal transfer function using techniques from the field of system-identification.","category":"page"},{"location":"tutorials/SampledData/#A-complete-example","page":"Getting started with Sampled-Data Systems","title":"A complete example","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Below, we model a simple continuous first-order system called plant that is controlled using a discrete-time controller controller. The reference signal is filtered using a discrete-time filter filt before being fed to the controller.","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"using ModelingToolkit, Plots, OrdinaryDiffEq\nusing ModelingToolkit: t_nounits as t\nusing ModelingToolkit: D_nounits as D\ndt = 0.5 # Sample interval\n@variables r(t)\nclock = Clock(dt)\nk = ShiftIndex(clock)\n\nfunction plant(; name)\n    @variables x(t)=1 u(t)=0 y(t)=0\n    D = Differential(t)\n    eqs = [D(x) ~ -x + u\n           y ~ x]\n    ODESystem(eqs, t; name = name)\nend\n\nfunction filt(; name) # Reference filter\n    @variables x(t)=0 u(t)=0 y(t)=0\n    a = 1 / exp(dt)\n    eqs = [x(k) ~ a * x(k - 1) + (1 - a) * u(k)\n           y ~ x]\n    ODESystem(eqs, t, name = name)\nend\n\nfunction controller(kp; name)\n    @variables y(t)=0 r(t)=0 ud(t)=0 yd(t)=0\n    @parameters kp = kp\n    eqs = [yd ~ Sample(y)\n           ud ~ kp * (r - yd)]\n    ODESystem(eqs, t; name = name)\nend\n\n@named f = filt()\n@named c = controller(1)\n@named p = plant()\n\nconnections = [r ~ (t >= 5)        # reference signal\n               f.u ~ r             # reference to filter input\n               f.y ~ c.r           # filtered reference to controller reference\n               Hold(c.ud) ~ p.u    # controller output to plant input (zero-order-hold)\n               p.y ~ c.y]          # plant output to controller feedback\n\n@named cl = ODESystem(connections, t, systems = [f, c, p])\ncl = complete(cl)","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"We can now simulate the system. JuliaSimCompiler is required to simulate hybrid continuous/discrete systems, we thus convert the system to an JuliaSimCompiler.IRSystem before calling structural_simplify","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"using JuliaSimCompiler, Plots\nssys = structural_simplify(IRSystem(cl))\n\nprob = ODEProblem(ssys, [\n    cl.f.x(k-1) => 0,\n], (0,15))\n\nsol = solve(prob, Tsit5())\nplot(sol, idxs=[cl.p.x, cl.c.ud], layout=(2,1))","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Note how the initial condition provided above refers to the value of f.x at a past time point. If we had not provided this initial condition, we would have gotten an error like this","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"try\n    ODEProblem(ssys, [], (0,15))\ncatch err\n    return err\nend","category":"page"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"The error message indicates that the -1 shift for f.x is not provided. The number 0.5 appearing in the error message is the period of the clock associated the variable for which an initial condition is missing f.x.","category":"page"},{"location":"tutorials/SampledData/#Further-reading","page":"Getting started with Sampled-Data Systems","title":"Further reading","text":"","category":"section"},{"location":"tutorials/SampledData/","page":"Getting started with Sampled-Data Systems","title":"Getting started with Sampled-Data Systems","text":"Analysis of linear sampled-data systems using ControlSystems.jl","category":"page"},{"location":"blocks/#Discrete-block-library","page":"Library API","title":"Discrete block library","text":"","category":"section"},{"location":"blocks/#Index","page":"Library API","title":"Index","text":"","category":"section"},{"location":"blocks/","page":"Library API","title":"Library API","text":"","category":"page"},{"location":"blocks/#Basic-blocks","page":"Library API","title":"Basic blocks","text":"","category":"section"},{"location":"blocks/","page":"Library API","title":"Library API","text":"Delay\nDifference\nDiscreteDerivative\nDiscreteIntegrator\nSampler\nZeroOrderHold","category":"page"},{"location":"blocks/#Noise-and-measurement-corruption","page":"Library API","title":"Noise and measurement corruption","text":"","category":"section"},{"location":"blocks/","page":"Library API","title":"Library API","text":"NormalNoise\nQuantization\nUniformNoise","category":"page"},{"location":"blocks/#Controllers","page":"Library API","title":"Controllers","text":"","category":"section"},{"location":"blocks/","page":"Library API","title":"Library API","text":"DiscretePIDParallel\nDiscretePIDStandard","category":"page"},{"location":"blocks/#Discrete-time-filters","page":"Library API","title":"Discrete-time filters","text":"","category":"section"},{"location":"blocks/","page":"Library API","title":"Library API","text":"ExponentialFilter","category":"page"},{"location":"blocks/#Docstrings","page":"Library API","title":"Docstrings","text":"","category":"section"},{"location":"blocks/","page":"Library API","title":"Library API","text":"Modules = [ModelingToolkitSampledData]\nPages   = [\"discrete_blocks.jl\"]","category":"page"},{"location":"blocks/#ModelingToolkitSampledData.ClockChanger","page":"Library API","title":"ModelingToolkitSampledData.ClockChanger","text":"ClockChanger()\nClockChanger(; to::AbstractClock, from::AbstractClock)\n\nConnectors:\n\ninput (continuous-time signal)\noutput (discrete-time signal)\n\ndanger: Experimental\nThe ClockChanger component is experimental and has known correctness issues. Please use with caution.\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.Delay","page":"Library API","title":"ModelingToolkitSampledData.Delay","text":"Delay(; n = 1)\n\nA discrete-time delay of n samples, corresponding to the transfer function z^-n.\n\nConnectors:\n\ninput\noutput\n\nStructural Parameters:\n\nn: Number of delay samples\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.Difference","page":"Library API","title":"ModelingToolkitSampledData.Difference","text":"Difference()\n\nA discrete-time difference operator, corresponding to the transfer function 1 - z^-1.\n\nConnectors:\n\ninput\noutput\n\nFor a discrete-time finite-difference derivative approximation, see DiscreteDerivative.\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.DiscreteDerivative","page":"Library API","title":"ModelingToolkitSampledData.DiscreteDerivative","text":"DiscreteDerivative(; k = 1)\n\nA discrete-time derivative filter, corresponding to the transfer function k (z-1)  (T_s z)\n\nwhere T_s is the sample time of the derivative filter.\n\nConnectors:\n\ninput\noutput\n\nParameters:\n\nk: Gain of derivative filter\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.DiscreteIntegrator","page":"Library API","title":"ModelingToolkitSampledData.DiscreteIntegrator","text":"DiscreteIntegrator(;name, k = 1, x = 0.0, method = :backward)\n\nOutputs y = ∫k*u dt, discretized to correspond to the one of the discrete-time transfer functions\n\nmethod = :forward: T_s  (z - 1)\nmethod = :backward: T_s z  (z - 1)\nmethod = :trapezoidal: (T_s  2) (z + 1)  (z - 1)\n\nwhere T_s is the sample time of the integrator.\n\nInitial value of integrator state x can be set with x\n\nConnectors:\n\ninput\noutput\n\nParameters:\n\nk: Gain of integrator\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.DiscretePIDParallel","page":"Library API","title":"ModelingToolkitSampledData.DiscretePIDParallel","text":"DiscretePIDParallel(;name, kp = 1, ki = 1, kd = 1, Ni = √(max(kd * ki, 1e-6)), Nd = 10kp, u_max = Inf, u_min = -u_max, wp = 1, wd = 1, Ts = 1, with_I = true, with_D = true, Imethod = :forward, Dmethod = :backward)\n\nDiscrete-time PID controller on parallel form with anti-windup and set-point weighting.\n\nThe controller is implemented on parallel form:\n\nSimplified:\n\nu = k_p e + int k_i e dt + k_d dfracdedt \n\nDetailed:\n\nu = k_p(w_p r - y) + int big( k_i (r - y) + N_i e_s big ) dt + k_d dfracddt(w_d r - y)\n\nwhere e_s = u - v is the saturated error signal, v is the unsaturated control signal and u is the saturated control signal.\n\nThe derivative is filtered to allow a maximum gain of N_d.\n\nThe integrator is discretized using the method specified by Imethod, options include\n\nImethod = :forward (default): Corresponding to the transfer function T_s  (z - 1)\nImethod = :backward: Corresponding to the transfer function T_s z  (z - 1)\nImethod = :trapezoidal: Corresponding to the transfer function (T_s  2) (z + 1)  (z - 1)\n\nThe derivative is discretized using the method specified by Dmethod, options include\n\nDmethod = :forward: Corresponding to the transfer function dfracN (z-1)z - dfrack_d-N T_sk_d.\nDmethod = :backward (default): Corresponding to the transfer function dfracdfracNk_dk_d + N T_s(z-1)z - dfrack_dk_d + N T_s\n\nAnti windup is realized by tracking using the gain N_i on the error signal e_s when the output is saturated.\n\nTo use the controller in 1DOF mode, i.e., with only the control error as input, connect the error signal to the reference connector, connect a Constant(; k = 0) to the measurement connector and set wp = wd = 1.\n\nConnectors:\n\nreference: The reference signal to the controller (or the error signal if used in 1DOF mode)\nmeasurement: The measurement feedback\nctr_output: The control signal output\n\nParameters:\n\nkp: Proportional gain\nki: Integral gain (only active if with_I = true)\nkd: Derivative gain (only active if with_D = true)\nNi: Anti-windup gain (only active if with_I = true)\nNd: Maximum derivative gain (only active if with_D = true). Typically set to 10-100 times the proportional gain.\nu_max: Maximum output above which the output is saturated\nu_min: Minimum output below which the output is saturated. This defaults to -u_max if u_max > 0 and -Inf otherwise.\nwp: [0, 1] Set-point weighting in the proportional part. Set to 0 to prevent step changes in the output due to step changes in the reference.\nwd: [0, 1] Set-point weighting in the derivative part. Set to 0 to prevent very large impulsive changes in the output due to step changes in the reference.\nwith_I: Whether or not to include the integral part\nwith_D: Whether or not to include the derivative part\nImethod: Discretization method for the integrator (see details above)\nDmethod: Discretization method for the derivative (see details above)\n\nExtended help:\n\nInternal variables:\n\nI: State of integrator\nD: State of filtered derivative\nr: Reference signal internal variable\ny: Measurement signal internal variable\nwde: Setpoint-weighted error for derivative\nv: Un-saturated output of the controller\nu: Saturated output of the controller\neI: Error signal input to integrator including anit-windup tracking signal\ne: Error signal\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.DiscretePIDStandard","page":"Library API","title":"ModelingToolkitSampledData.DiscretePIDStandard","text":"DiscretePIDStandard(;name, K = 1, Ti = 1, Td = 1, Ni = √(max(kd * ki, 1e-6)), Nd = 10, u_max = Inf, u_min = -u_max, wp = 1, wd = 1, Ts = 1, with_I = true, with_D = true, Imethod = :forward, Dmethod = :backward)\n\nDiscrete-time PID controller on standard (ideal) form with anti-windup and set-point weighting.\n\nThe controller is implemented on standard form\n\nSimplified:\n\nu = K left( e + int frac1T_i e  dt + T_d dfracdedt right)\n\nDetailed:\n\nu = K left( (w_p r - y) + int big( frac1T_i (r - y) + N_i e_s big ) dt + T_d dfracddt(w_d r - y) right)\n\nwhere e_s = u - v is the saturated error signal, v is the unsaturated control signal and u is the saturated control signal.\n\nThe derivative is filtered to allow a maximum gain of N_d.\n\nThe integrator is discretized using the method specified by Imethod, options include\n\nImethod = :forward (default): Corresponding to the transfer function T_s  (z - 1)\nImethod = :backward: Corresponding to the transfer function T_s z  (z - 1)\nImethod = :trapezoidal: Corresponding to the transfer function (T_s  2) (z + 1)  (z - 1)\n\nThe derivative is discretized using the method specified by Dmethod, options include\n\nDmethod = :forward: Corresponding to the transfer function dfracN (z-1)z - dfracT_d-N T_sT_d.\nDmethod = :backward (default): Corresponding to the transfer function dfracdfracNT_dT_d + N T_s(z-1)z - dfracT_dT_d + N T_s\n\nAnti windup is realized by tracking using the gain N_i on the error signal e_s when the output is saturated.\n\nTo use the controller in 1DOF mode, i.e., with only the control error as input, connect the error signal to the reference connector, connect a Constant(; k = 0) to the measurement connector and set wp = wd = 1.\n\nConnectors:\n\nreference: The reference signal to the controller (or the error signal if used in 1DOF mode)\nmeasurement: The measurement feedback\nctr_output: The control signal output\n\nParameters:\n\nK: Proportional gain\nTi: Integral time constant (only active if with_I = true)\nTd: Derivative time (only active if with_D = true)\nNi: Anti-windup gain (only active if with_I = true)\nNd: Maximum derivative gain (only active if with_D = true). Typically set to 10-100.\nu_max: Maximum output above which the output is saturated\nu_min: Minimum output below which the output is saturated. This defaults to -u_max if u_max > 0 and -Inf otherwise.\nwp: [0, 1] Set-point weighting in the proportional part. Set to 0 to prevent step changes in the output due to step changes in the reference.\nwd: [0, 1] Set-point weighting in the derivative part. Set to 0 to prevent very large impulsive changes in the output due to step changes in the reference.\nwith_I: Whether or not to include the integral part\nwith_D: Whether or not to include the derivative part\nImethod: Discretization method for the integrator (see details above)\nDmethod: Discretization method for the derivative (see details above)\n\nExtended help:\n\nInternal variables:\n\nI: State of integrator\nD: State of filtered derivative\nr: Reference signal internal variable\ny: Measurement signal internal variable\nwde: Setpoint-weighted error for derivative\nv: Un-saturated output of the controller\nu: Saturated output of the controller\neI: Error signal input to integrator including anit-windup tracking signal\ne: Error signal\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.ExponentialFilter","page":"Library API","title":"ModelingToolkitSampledData.ExponentialFilter","text":"ExponentialFilter(a = 0.1)\n\nExponential filtering with input-output relation y(z)  (1 - a) y(z-1) + a u(z-1)\n\nParameters:\n\na: Filter parameter [0, 1], a small value implies stronger filtering. \n\nVariables:\n\nu: Input signal\ny: Output signal\n\nConnectors:\n\ninput::RealInput: Input signal\noutput::RealOutput: Output signal\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.NormalNoise","page":"Library API","title":"ModelingToolkitSampledData.NormalNoise","text":"NormalNoise()\n\nA discrete-time noise source that returns a normally-distributed value at each clock tick.\n\nParameters\n\nmu = 0: Mean\nsigma = 1: Standard deviation\nseed = 1: Seed for the random number generator\n\nStructural parameters\n\nz: The ShiftIndex used to indicate clock partition.\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.Quantization","page":"Library API","title":"ModelingToolkitSampledData.Quantization","text":"Quantization\n\nA quantization block that quantizes the input signal to a specified number of bits.\n\nParameters:\n\ny_max: Upper limit of output\ny_min: Lower limit of output\nbits: Number of bits of quantization\nquantized: If quantization effects shall be computed. If false, the output is equal to the input, which may be useful for, e.g., linearization.\nmidrise: (structural) If true (default), the quantizer is a midrise quantizer, otherwise it is a midtread quantizer. See Docs: Quantization for more details.\n\nConnectors:\n\ninput\noutput\n\nVariables\n\ny: Output signal, equal to output.u\nu: Input signal, equal to input.u\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.Sampler","page":"Library API","title":"ModelingToolkitSampledData.Sampler","text":"Sampler()\nSampler(; dt::Real)\nSampler(; clock::AbstractClock)\n\nSampler transforms a continuous-time signal into discrete time by sampling the input signal every time the associated clock ticks. The clock can be specified explicitly using the clock keyword argument, or implicitly by providing a sample time dt, in which case a standard periodic Clock is used. \n\nConnectors:\n\ninput (continuous-time signal)\noutput (discrete-time signal)\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.UniformNoise","page":"Library API","title":"ModelingToolkitSampledData.UniformNoise","text":"UniformNoise()\n\nA discrete-time noise source that returns a uniformly distributed value at each clock tick.\n\nParameters\n\nl = 0: Lower bound\nu = 1: Upper bound\nseed = 1: Seed for the random number generator\n\nStructural parameters\n\nrng: A random number generator, defaults to Random.Xoshiro().\nz: The ShiftIndex used to indicate clock partition.\n\nConnectors:\n\noutput\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.ZeroOrderHold","page":"Library API","title":"ModelingToolkitSampledData.ZeroOrderHold","text":"ZeroOrderHold()\n\nZero-order-Hold translates a discrete time (clocked) signal into continuous time by holding the value of the discrete signal constant until the next sample.\n\nConnectors:\n\ninput (discrete-time signal)\noutput (continuous-time signal)\n\n\n\n\n\n","category":"constant"},{"location":"blocks/#ModelingToolkitSampledData.seeded_rand-Tuple{Any, Any}","page":"Library API","title":"ModelingToolkitSampledData.seeded_rand","text":"seeded_rand(seed, t)\n\nInternal function. This function seeds the seed parameter as well as the current simulation time.\n\n\n\n\n\n","category":"method"},{"location":"blocks/#ModelingToolkitSampledData.seeded_randn-Tuple{Any, Any}","page":"Library API","title":"ModelingToolkitSampledData.seeded_randn","text":"seeded_randn(seed, t)\n\nInternal function. This function seeds the seed parameter as well as the current simulation time.\n\n\n\n\n\n","category":"method"},{"location":"examples/dc_motor_pi/#DC-Motor-with-PI-controller","page":"Controlled DC motor","title":"DC Motor with PI-controller","text":"","category":"section"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"In this example, a PI-controller is set up for speed control of a DC-motor. An equivalent circuit diagram is depicted below.","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"(Image: DC-motor)","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"First, a continuous-time velocity controller will be used, we then change the controller to be implemented in discrete-time in Discrete-time controller. Finally, we add an outer position controller in Adding a slower outer position loop.","category":"page"},{"location":"examples/dc_motor_pi/#Modeling-and-simulation","page":"Controlled DC motor","title":"Modeling and simulation","text":"","category":"section"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"The electrical part consists of a resistance and inductance. The coupling between the electrical and rotational domain is done via an electro-motive force (EMF) component. The voltage across the EMF is proportional to the angular velocity and the current is proportional to the torque. On the mechanical side, viscous friction in, e.g., a bearing and the inertia of the shaft is modelled.","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"A PI-controller with anti-windup measure should be used as a speed controller. A simulation is performed to verify the tracking performance of the controller and the disturbance rejection capabilities.","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"First, the needed packages are imported and the parameters of the model defined.","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t\nusing ModelingToolkitStandardLibrary.Electrical\nusing ModelingToolkitStandardLibrary.Mechanical.Rotational\nusing ModelingToolkitStandardLibrary.Blocks\nusing OrdinaryDiffEq\nusing Plots\n\nR = 0.5 # [Ohm] armature resistance\nL = 4.5e-3 # [H] armature inductance\nk = 0.5 # [N.m/A] motor constant\nJ = 0.02 # [kg.m²] inertia\nf = 0.01 # [N.m.s/rad] friction factor\ntau_L_step = -0.3 # [N.m] amplitude of the load torque step\nnothing # hide","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"The actual model can now be composed.","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"@named ground = Ground()\n@named source = Voltage()\n@named ref = Blocks.Step(height = 1, start_time = 0)\n@named pi_controller = Blocks.LimPI(k = 1.1, T = 0.035, u_max = 10, Ta = 0.035)\n@named feedback = Blocks.Feedback()\n@named R1 = Resistor(R = R)\n@named L1 = Inductor(L = L)\n@named emf = EMF(k = k)\n@named fixed = Fixed()\n@named load = Torque()\n@named load_step = Blocks.Step(height = tau_L_step, start_time = 1.3)\n@named inertia = Inertia(J = J)\n@named friction = Damper(d = f)\n@named speed_sensor = SpeedSensor()\n\nconnections = [connect(fixed.flange, emf.support, friction.flange_b)\n               connect(emf.flange, friction.flange_a, inertia.flange_a)\n               connect(inertia.flange_b, load.flange)\n               connect(inertia.flange_b, speed_sensor.flange)\n               connect(load_step.output, load.tau)\n               connect(ref.output, feedback.input1)\n               connect(speed_sensor.w, feedback.input2)\n               connect(feedback.output, pi_controller.err_input)\n               connect(pi_controller.ctr_output, source.V)\n               connect(source.p, R1.p)\n               connect(R1.n, L1.p)\n               connect(L1.n, emf.p)\n               connect(emf.n, source.n, ground.g)]\n\n@named model = ODESystem(connections, t,\n    systems = [\n        ground,\n        ref,\n        pi_controller,\n        feedback,\n        source,\n        R1,\n        L1,\n        emf,\n        fixed,\n        load,\n        load_step,\n        inertia,\n        friction,\n        speed_sensor\n    ])\nmodel = complete(model)\nnothing # hide","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"Now the model can be simulated. Typical rotational mechanical systems are described via DAE (differential algebraic equations), however in this case, ModelingToolkit can simplify the model enough so that it can be represented as a system of ODEs (ordinary differential equations).","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"sys = structural_simplify(model)\nprob = ODEProblem(sys, unknowns(sys) .=> 0.0, (0, 2.0))\nsol = solve(prob, Tsit5())\n\np1 = Plots.plot(sol.t, sol[inertia.w], ylabel = \"Angular Vel. in rad/s\",\n    label = \"Measurement\", title = \"DC Motor with Speed Controller\")\nPlots.plot!(sol.t, sol[ref.output.u], label = \"Reference\")\np2 = Plots.plot(sol.t, sol[load.tau.u], ylabel = \"Disturbance in Nm\", label = \"\")\nPlots.plot(p1, p2, layout = (2, 1))","category":"page"},{"location":"examples/dc_motor_pi/#Discrete-time-controller","page":"Controlled DC motor","title":"Discrete-time controller","text":"","category":"section"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"Until now, we have modeled both the physical part of the system, the DC motor, and the control systems, in continuous time. In practice, it is common to implement control systems on a computer operating at a fixed sample rate, i.e, in discrete time. A system containing both continuous-time parts and discrete-time parts is often referred to as a \"sampled-data system\", and the ModelingToolkit standard library together with ModelingToolkitSampledData.jl contain several components to model such systems.","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"Below, we re-model the system, this time with a discrete-time controller: DiscretePIDStandard. To interface between the continuous and discrete parts of the model, we make use of a Sampler and ZeroOrderHold blocks. Apart from the three aforementioned components, the model is the same as before.","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"using ModelingToolkitSampledData\nusing JuliaSimCompiler\n\nz = ShiftIndex()\n@mtkmodel DiscreteClosedLoop begin\n    @structural_parameters begin\n        use_ref = true\n    end\n    @components begin\n        ground = Ground()\n        source = Voltage()\n        ref = Blocks.Step(height = 1, start_time = 0, smooth = false)\n        sampler = Sampler(dt = 0.005)\n        pi_controller = DiscretePIDStandard(\n            K = 1, Ti = 0.035, u_max = 10, with_D = false)\n        zoh = ZeroOrderHold()\n        R1 = Resistor(R = R)\n        L1 = Inductor(L = L)\n        emf = EMF(k = k)\n        fixed = Fixed()\n        load = Torque()\n        load_step = Blocks.Step(height = tau_L_step, start_time = 1.3)\n        inertia = Inertia(J = J)\n        friction = Damper(d = f)\n        speed_sensor = SpeedSensor()\n        angle_sensor = AngleSensor()\n    end\n\n    @equations begin\n        connect(fixed.flange, emf.support, friction.flange_b)\n        connect(emf.flange, friction.flange_a, inertia.flange_a)\n        connect(inertia.flange_b, load.flange)\n        connect(inertia.flange_b, speed_sensor.flange, angle_sensor.flange)\n        connect(load_step.output, load.tau)\n        if use_ref\n            connect(ref.output, pi_controller.reference)\n        end\n        connect(speed_sensor.w, sampler.input)\n        connect(sampler.output, pi_controller.measurement)\n        connect(pi_controller.ctr_output, zoh.input)\n        connect(zoh.output, source.V)\n        connect(source.p, R1.p)\n        connect(R1.n, L1.p)\n        connect(L1.n, emf.p)\n        connect(emf.n, source.n, ground.g)\n    end\nend\n\n@named disc_model = DiscreteClosedLoop()\ndisc_model = complete(disc_model)\nssys = structural_simplify(IRSystem(disc_model)) # Conversion to an IRSystem from JuliaSimCompiler is required for sampled-data systems\n\ndisc_prob = ODEProblem(ssys, [unknowns(disc_model) .=> 0.0; disc_model.pi_controller.I(z-1) => 0; disc_model.pi_controller.eI(z-1) => 0], (0, 2.0))\ndisc_sol = solve(disc_prob, Tsit5())\n\nPlots.plot(sol.t, sol[inertia.w], ylabel = \"Angular Vel. in rad/s\",\n    label = \"Measurement (cont. controller)\", title = \"DC Motor with Speed Controller\")\nPlots.plot!(disc_sol.t, disc_sol[inertia.w], ylabel = \"Angular Vel. in rad/s\",\n    label = \"Measurement (disc. controller)\", title = \"DC Motor with Discrete-time Speed Controller\", legend=:bottomleft, dpi=600)\nlens!([1.2, 1.6], [0.75, 1.02], inset=(1, bbox(.6, .5, .3, .4))) # 1 is subplot index","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"In the plot above, we compare the result of the discrete-time control system to the continuous-time result from before. We see that with the chosen sample-interval of dt=0.005 (provided to the Sampler block), we have a slight degradation in the control performance as a consequence of the discretization.","category":"page"},{"location":"examples/dc_motor_pi/#Adding-a-slower-outer-position-loop","page":"Controlled DC motor","title":"Adding a slower outer position loop","text":"","category":"section"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"Below, we add an outer control loop that controls the position of the motor by manipulating the reference to the inner speed controller. This is a common control strategy, often referred to as cascade control.","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"(Image: block diagram of a cascade control loop)","category":"page"},{"location":"examples/dc_motor_pi/","page":"Controlled DC motor","title":"Controlled DC motor","text":"@mtkmodel Cascade begin\n    @components begin\n        inner = DiscreteClosedLoop(use_ref = false)\n        sampler = Sampler(clock = Clock(0.005))\n        # cc = ClockChanger(from = get_clock(sampler), to = get_clock(inner.sampler)) # Currently deactivated due to bug\n        cc = Gain(k = 1)\n        ref = Blocks.Ramp(height = 1, start_time = 0.05, duration = 0.85, smooth = false)\n        ref_diff = DiscreteDerivative() # This will differentiate q_ref to q̇_ref\n        add = Blocks.Add()      # The middle ∑ block in the diagram\n        p_controller = DiscretePIDStandard(K = 20, with_D = false, with_I = false)\n    end\n    @parameters begin\n        O = 0\n    end\n    begin\n        from = get_clock(sampler)\n        to = get_clock(inner.sampler)\n    end\n    @equations begin\n        # cc.y(ShiftIndex(to)) ~ ClockChange(; from, to)(cc.u(ShiftIndex(from))) + O\n        # cc.y ~ ClockChange(; from, to)(cc.u) + eps()^10\n        # cc.y ~ cc.u\n        connect(ref.output, p_controller.reference, ref_diff.input)\n        connect(ref_diff.output, add.input1)\n        connect(add.output, cc.input)\n        connect(cc.output, inner.pi_controller.reference)\n        connect(p_controller.ctr_output, add.input2)\n        connect(inner.angle_sensor.phi, sampler.input)\n        connect(sampler.output, p_controller.measurement)\n    end\nend\n\n@named cascade = Cascade()\ncascade = complete(cascade)\nssys = structural_simplify(IRSystem(cascade))\ni = cascade.inner\ncascade_prob = ODEProblem(ssys, [\n    unknowns(cascade) .=> 0.0;\n    i.pi_controller.I(z-1) => 0;\n    i.pi_controller.eI(z-1) => 0;\n    cascade.p_controller.I(z-1) => 0;\n    cascade.ref_diff.u(z-1) => 0.0;\n    cascade.cc.u(z-1) => 0.0;\n    ], (0, 2))\ncascade_sol = solve(cascade_prob, Tsit5())\nPlots.plot(cascade_sol, idxs = [i.inertia.phi, i.inertia.w, i.zoh.u])","category":"page"},{"location":"tutorials/noise/#Measurement-noise-and-corruption","page":"Noise and measurement corruption","title":"Measurement noise and corruption","text":"","category":"section"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"Measurement noise is practically always present in signals originating from real-world sensors. In a sampled-data system, analyzing the influence of measurement noise using simulation is relatively straight forward. Below, we add Gaussian white noise to the speed sensor signal in the DC-motor example from DC Motor with PI-controller. The noise is added using the NormalNoise block.","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"This block has two modes of operation","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"If additive = false (default), the block has the connector output only, and this output is the noise signal.\nIf additive = true, the block has the connectors input and output, and the output is the sum of the input and the noise signal, i.e., the noise is added to the input signal. This mode makes it convenient to add noise to a signal in a sampled-data system.","category":"page"},{"location":"tutorials/noise/#Example:-Noise","page":"Noise and measurement corruption","title":"Example: Noise","text":"","category":"section"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"This example is a continuation of the DC-motor example from DC Motor with PI-controller. We add Gaussian white noise with σ^2 = 01^2 to the speed sensor signal.","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t\nusing ModelingToolkitStandardLibrary.Electrical\nusing ModelingToolkitStandardLibrary.Mechanical.Rotational\nusing ModelingToolkitStandardLibrary.Blocks\nusing ModelingToolkitSampledData\nusing JuliaSimCompiler\nusing OrdinaryDiffEq\nusing Plots\n\nR = 0.5 # [Ohm] armature resistance\nL = 4.5e-3 # [H] armature inductance\nk = 0.5 # [N.m/A] motor constant\nJ = 0.02 # [kg.m²] inertia\nf = 0.01 # [N.m.s/rad] friction factor\ntau_L_step = -0.3 # [N.m] amplitude of the load torque step\nnothing # hide\n\nz = ShiftIndex()\n\n@mtkmodel NoisyClosedLoop begin\n    @components begin\n        ground = Ground()\n        source = Voltage()\n        ref = Blocks.Step(height = 1, start_time = 0, smooth = false)\n        sampler = Sampler(dt = 0.002)\n        noise = NormalNoise(sigma = 0.1, additive = true)\n        pi_controller = DiscretePIDStandard(\n            K = 1, Ti = 0.035, u_max = 10, with_D = false)\n        zoh = ZeroOrderHold()\n        R1 = Resistor(R = R)\n        L1 = Inductor(L = L)\n        emf = EMF(k = k)\n        fixed = Fixed()\n        load = Torque()\n        load_step = Blocks.Step(height = tau_L_step, start_time = 1.3)\n        inertia = Inertia(J = J)\n        friction = Damper(d = f)\n        speed_sensor = SpeedSensor()\n        angle_sensor = AngleSensor()\n    end\n\n    @equations begin\n        connect(fixed.flange, emf.support, friction.flange_b)\n        connect(emf.flange, friction.flange_a, inertia.flange_a)\n        connect(inertia.flange_b, load.flange)\n        connect(inertia.flange_b, speed_sensor.flange, angle_sensor.flange)\n        connect(load_step.output, load.tau)\n        connect(ref.output, pi_controller.reference)\n        connect(speed_sensor.w, sampler.input)\n        connect(sampler.output, noise.input)\n        connect(noise.output, pi_controller.measurement)\n        connect(pi_controller.ctr_output, zoh.input)\n        connect(zoh.output, source.V)\n        connect(source.p, R1.p)\n        connect(R1.n, L1.p)\n        connect(L1.n, emf.p)\n        connect(emf.n, source.n, ground.g)\n    end\nend\n\n\n@named noisy_model = NoisyClosedLoop()\nnoisy_model = complete(noisy_model)\nssys = structural_simplify(IRSystem(noisy_model)) # Conversion to an IRSystem from JuliaSimCompiler is required for sampled-data systems\n\nnoise_prob = ODEProblem(ssys, [unknowns(noisy_model) .=> 0.0; noisy_model.pi_controller.I(z-1) => 0; noisy_model.pi_controller.eI(z-1) => 0; noisy_model.noise.y(z-1) => 0], (0, 2.0))\nnoise_sol = solve(noise_prob, Tsit5())\n\nfigy = plot(noise_sol, idxs=noisy_model.noise.y, label = \"Measured speed\", )\nplot!(noise_sol, idxs=noisy_model.inertia.w, ylabel = \"Angular Vel. [rad/s]\",\n    label = \"Actual speed\", legend=:bottomleft, dpi=600, l=(2, :blue))\nfigu = plot(noise_sol, idxs=noisy_model.source.V.u, label = \"Control signal [V]\", )\nplot(figy, figu, plot_title = \"DC Motor with Discrete-time Speed Controller\")","category":"page"},{"location":"tutorials/noise/#Noise-filtering","page":"Noise and measurement corruption","title":"Noise filtering","text":"","category":"section"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"You may, e.g.","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"Use ExponentialFilter to add exponential filtering using y(k) ~ (1-a)y(k-1) + a*u(k), where a is the filter coefficient and u is the signal to be filtered.\nAdd moving average filtering using y(k) ~ 1/N sum(i->u(k-i), i=0:N-1), where N is the number of samples to average over.","category":"page"},{"location":"tutorials/noise/#Colored-noise","page":"Noise and measurement corruption","title":"Colored noise","text":"","category":"section"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"Colored noise can be achieved by filtering white noise through a filter with the desired spectrum. No components are available for this yet.","category":"page"},{"location":"tutorials/noise/#Internal-details","page":"Noise and measurement corruption","title":"Internal details","text":"","category":"section"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"Internally, a random number generator from StableRNGs.jl is used to produce reproducible streams of random numbers. Each draw of a random number is seeded by hash(t, hash(seed)), where seed is a parameter in the noise source component, and t is the current simulation time. This ensures that","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"The user can alter the stream of random numbers with seed.\nMultiple calls to the random number generator at the same time step all return the same number.","category":"page"},{"location":"tutorials/noise/#Quantization","page":"Noise and measurement corruption","title":"Quantization","text":"","category":"section"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"A signal may be quantized to a fixed number of levels (e.g., 8-bit) using the Quantization block. This may be used to simulate, e.g., the quantization that occurs in a AD converter. Below, we have a simple example where a sine wave is quantized to 2 bits (4 levels), limited between -1 and 1:","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"using ModelingToolkit, ModelingToolkitSampledData, OrdinaryDiffEq, Plots\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing ModelingToolkitStandardLibrary.Blocks\nusing JuliaSimCompiler\nz = ShiftIndex(Clock(0.1))\n@mtkmodel QuantizationModel begin\n    @components begin\n        input = Sine(amplitude=1.5, frequency=1)\n        quant = Quantization(; z, bits=2, y_min = -1, y_max = 1)\n    end\n    @variables begin\n        x(t) = 0 # Dummy variable to work around a bug for models without continuous-time state\n    end\n    @equations begin\n        connect(input.output, quant.input)\n        D(x) ~ 0 # Dummy equation\n    end\nend\n@named m = QuantizationModel()\nm = complete(m)\nssys = structural_simplify(IRSystem(m))\nprob = ODEProblem(ssys, [], (0.0, 2.0))\nsol = solve(prob, Tsit5())\nplot(sol, idxs=m.input.output.u)\nplot!(sol, idxs=m.quant.y, label=\"Quantized output\")","category":"page"},{"location":"tutorials/noise/#Different-quantization-modes","page":"Noise and measurement corruption","title":"Different quantization modes","text":"","category":"section"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"With the default option midrise = true, the output of the quantizer is always between y_min and y_max inclusive, and the number of distinct levels it can take is 2^bits. The possible values are given by","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"bits = 2; y_min = -1; y_max = 1\ncollect(range(y_min, stop=y_max, length=2^bits))","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"Notably, these possible levels do not include 0. If midrise = false, a mid-tread quantizer is used instead. The two options are visualized below:","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"y_min = -1; y_max = 1; bits = 2\nu = y_min:0.01:y_max\ny_mr = ModelingToolkitSampledData.quantize_midrise.(u, bits, y_min, y_max)\ny_mt = ModelingToolkitSampledData.quantize_midtread.(u, bits, y_min, y_max)\nplot(u, [y_mr y_mt], label=[\"Midrise\" \"Midtread\"], xlabel=\"Input\", ylabel=\"Output\", framestyle=:zerolines, l=2, seriestype=:step)","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"Note how the default mid-rise quantizer mode has a rise at the middle of the interval, while the mid-tread mode has a flat region (a tread) centered around the middle of the interval.","category":"page"},{"location":"tutorials/noise/","page":"Noise and measurement corruption","title":"Noise and measurement corruption","text":"The default option midrise = true includes both end points as possible output values, while midrise = false does not include the upper limit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ModelingToolkitSampledData","category":"page"},{"location":"#ModelingToolkitSampledData","page":"Home","title":"ModelingToolkitSampledData","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ModelingToolkitSampledData.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkitSampledData.jl contains standard-library components for discrete-time systems, which when used in a model together with continuous time differential equations forms a sampled-data system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Common examples of sampled-data systems are","category":"page"},{"location":"","page":"Home","title":"Home","text":"Control systems, such as when a physical device is controlled by a computer.\nSignal-processing systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To learn about the fundamentals of sampled-data modeling in ModelingToolkit, check out the tutorial Clocks and Sampled-Data Systems, to see a practical example using standard-library components, have a look at DC Motor with PI-controller. To read the docstrings of the available components, see Discrete block library.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this library, first follow the installation instructions for JuliaSimCompiler. In particular, you need to add the JuliaHub Registry. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the registry is added and JuliaSimCompiler is installed, you may install this package. This package is also registered in the JuliaHubRegistry, so you may add it with","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ModelingToolkitSampledData","category":"page"},{"location":"","page":"Home","title":"Home","text":"after you have followed the steps above.","category":"page"}]
}
