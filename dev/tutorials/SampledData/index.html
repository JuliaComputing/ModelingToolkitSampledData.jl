<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started with Sampled-Data Systems Â· ModelingToolkitSampledData.jl</title><meta name="title" content="Getting started with Sampled-Data Systems Â· ModelingToolkitSampledData.jl"/><meta property="og:title" content="Getting started with Sampled-Data Systems Â· ModelingToolkitSampledData.jl"/><meta property="twitter:title" content="Getting started with Sampled-Data Systems Â· ModelingToolkitSampledData.jl"/><meta name="description" content="Documentation for ModelingToolkitSampledData.jl."/><meta property="og:description" content="Documentation for ModelingToolkitSampledData.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkitSampledData.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkitSampledData.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Getting started with Sampled-Data Systems</a><ul class="internal"><li><a class="tocitem" href="#Clocks,-operators-and-difference-equations"><span>Clocks, operators and difference equations</span></a></li><li><a class="tocitem" href="#Higher-order-shifts"><span>Higher-order shifts</span></a></li><li><a class="tocitem" href="#Initial-conditions"><span>Initial conditions</span></a></li><li><a class="tocitem" href="#Multiple-clocks"><span>Multiple clocks</span></a></li><li><a class="tocitem" href="#Accessing-discrete-time-variables-in-the-solution"><span>Accessing discrete-time variables in the solution</span></a></li><li><a class="tocitem" href="#Implementing-generic-discrete-time-components"><span>Implementing generic discrete-time components</span></a></li><li><a class="tocitem" href="#Linearization-of-sampled-data-systems"><span>Linearization of sampled-data systems</span></a></li><li><a class="tocitem" href="#A-complete-example"><span>A complete example</span></a></li><li><a class="tocitem" href="#Further-reading"><span>Further reading</span></a></li></ul></li><li><a class="tocitem" href="../noise/">Noise and measurement corruption</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/dc_motor_pi/">Controlled DC motor</a></li><li><a class="tocitem" href="../../examples/onoffcontroller/">On-off controller</a></li><li><a class="tocitem" href="../../examples/sliding_mode_control/">Sliding-mode control</a></li></ul></li><li><a class="tocitem" href="../../blocks/">Library API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Getting started with Sampled-Data Systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started with Sampled-Data Systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/ModelingToolkitSampledData.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Clocks-and-Sampled-Data-Systems"><a class="docs-heading-anchor" href="#Clocks-and-Sampled-Data-Systems">Clocks and Sampled-Data Systems</a><a id="Clocks-and-Sampled-Data-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Clocks-and-Sampled-Data-Systems" title="Permalink"></a></h1><p>A sampled-data system contains both continuous-time and discrete-time components, such as a continuous-time plant model and a discrete-time control system. ModelingToolkit supports the modeling and simulation of sampled-data systems by means of <em>clocks</em>.</p><div class="admonition is-danger"><header class="admonition-header">Experimental</header><div class="admonition-body"><p>The sampled-data interface in ModelingToolkit is currently experimental and at any time subject to breaking changes <strong>not</strong> respecting semantic versioning.</p></div></div><div class="admonition is-info"><header class="admonition-header">Negative shifts</header><div class="admonition-body"><p>The initial release of the sampled-data interface <strong>only supports negative shifts</strong>.</p></div></div><h2 id="Clocks,-operators-and-difference-equations"><a class="docs-heading-anchor" href="#Clocks,-operators-and-difference-equations">Clocks, operators and difference equations</a><a id="Clocks,-operators-and-difference-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Clocks,-operators-and-difference-equations" title="Permalink"></a></h2><p>A clock can be seen as an <em>event source</em>, i.e., when the clock ticks, an event is generated. In response to the event the discrete-time logic is executed, for example, a control signal is computed. For basic modeling of sampled-data systems, the user does not have to interact with clocks explicitly, instead, the modeling is performed using the operators</p><ul><li><p><a href="@ref"><code>ModelingToolkit.Sample</code></a></p></li><li><p><a href="@ref"><code>ModelingToolkit.Hold</code></a></p></li><li><p><a href="@ref"><code>ModelingToolkit.ShiftIndex</code></a></p><p>or their corresponding components</p></li><li><p><a href="../../blocks/#ModelingToolkitSampledData.Sampler"><code>ModelingToolkitSampledData.Sampler</code></a></p></li><li><p><a href="../../blocks/#ModelingToolkitSampledData.ZeroOrderHold"><code>ModelingToolkitSampledData.ZeroOrderHold</code></a></p></li></ul><p>When a continuous-time variable <code>x</code> is sampled using <code>xd = Sample(x, dt)</code>, the result is a discrete-time variable <code>xd</code> that is defined and updated whenever the clock ticks. <code>xd</code> is <em>only defined when the clock ticks</em>, which it does with an interval of <code>dt</code>. If <code>dt</code> is unspecified, the tick rate of the clock associated with <code>xd</code> is inferred from the context in which <code>xd</code> appears. Any variable taking part in the same equation as <code>xd</code> is inferred to belong to the same <em>discrete partition</em> as <code>xd</code>, i.e., belonging to the same clock. A system may contain multiple different discrete-time partitions, each with a unique clock. This allows for modeling of multi-rate systems and discrete-time processes located on different computers etc.</p><p>To make a discrete-time variable available to the continuous partition, the <code>Hold</code> operator is used. <code>xc = Hold(xd)</code> creates a continuous-time variable <code>xc</code> that is updated whenever the clock associated with <code>xd</code> ticks, and holds its value constant between ticks.</p><p>The operators <code>Sample</code> and <code>Hold</code> are thus providing the interface between continuous and discrete partitions.</p><p>The <code>ShiftIndex</code> operator is used to refer to past and future values of discrete-time variables. The example below illustrates its use, implementing the discrete-time system</p><p class="math-container">\[x(k+1) = 0.5x(k) + u(k)
y(k) = x(k)\]</p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t
@variables x(t) y(t) u(t)
dt = 0.1                # Sample interval
clock = Clock(dt)    # A periodic clock with tick rate dt
k = ShiftIndex(clock)

eqs = [
    x(k) ~ 0.5x(k - 1) + u(k - 1),
    y ~ x
]</code></pre><p class="math-container">\[ \begin{align}
x\left( t \right) &amp;= 0.5 \mathrm{Shift(t, -1)}\left( x\left( t \right) \right) + \mathrm{Shift(t, -1)}\left( u\left( t \right) \right) \\
y\left( t \right) &amp;= x\left( t \right)
\end{align}
 \]</p><p>A few things to note in this basic example:</p><ul><li>The equation <code>x(k+1) = 0.5x(k) + u(k)</code> has been rewritten in terms of negative shifts since positive shifts are not yet supported.</li><li><code>x</code> and <code>u</code> are automatically inferred to be discrete-time variables, since they appear in an equation with a discrete-time <code>ShiftIndex</code> <code>k</code>.</li><li><code>y</code> is also automatically inferred to be a discrete-time-time variable, since it appears in an equation with another discrete-time variable <code>x</code>. <code>x,u,y</code> all belong to the same discrete-time partition, i.e., they are all updated at the same <em>instantaneous point in time</em> at which the clock ticks.</li><li>The equation <code>y ~ x</code> does not use any shift index, this is equivalent to <code>y(k) ~ x(k)</code>, i.e., discrete-time variables without shift index are assumed to refer to the variable at the current time step.</li><li>The equation <code>x(k) ~ 0.5x(k-1) + u(k-1)</code> indicates how <code>x</code> is updated, i.e., what the value of <code>x</code> will be at the <em>current</em> time step in terms of the <em>past</em> value. The output <code>y</code>, is given by the value of <code>x</code> at the <em>current</em> time step, i.e., <code>y(k) ~ x(k)</code>. If this logic was implemented in an imperative programming style, the logic would thus be</li></ul><pre><code class="language-julia hljs">function discrete_step(x, u)
    x = 0.5x + u # x is updated to a new value, i.e., x(k) is computed
    y = x # y is assigned the current value of x, y(k) = x(k)
    return x, y # The state x now refers to x at the current time step, x(k), and y equals x, y(k) = x(k)
end</code></pre><p>An alternative and <em>equivalent</em> way of writing the same system is</p><pre><code class="language-julia hljs">eqs = [
    x(k + 1) ~ 0.5x(k) + u(k),
    y(k) ~ x(k)
]</code></pre><p class="math-container">\[ \begin{align}
\mathrm{Shift(t, 1)}\left( x\left( t \right) \right) &amp;= u\left( t \right) + 0.5 x\left( t \right) \\
y\left( t \right) &amp;= x\left( t \right)
\end{align}
 \]</p><p>but the use of positive time shifts is not yet supported. Instead, we <em>shifted all indices</em> by <code>-1</code> above, resulting in exactly the same difference equations. However, the next system is <em>not equivalent</em> to the previous one:</p><pre><code class="language-julia hljs">eqs = [
    x(k) ~ 0.5x(k - 1) + u(k),
    y ~ x
]</code></pre><p class="math-container">\[ \begin{align}
x\left( t \right) &amp;= u\left( t \right) + 0.5 \mathrm{Shift(t, -1)}\left( x\left( t \right) \right) \\
y\left( t \right) &amp;= x\left( t \right)
\end{align}
 \]</p><p>In this last example, <code>u(k)</code> refers to the input at the new time point <code>k</code>., this system is equivalent to</p><pre><code class="nohighlight hljs">eqs = [
    x(k+1) ~ 0.5x(k) + u(k+1),
    y(k) ~ x(k)
]</code></pre><h2 id="Higher-order-shifts"><a class="docs-heading-anchor" href="#Higher-order-shifts">Higher-order shifts</a><a id="Higher-order-shifts-1"></a><a class="docs-heading-anchor-permalink" href="#Higher-order-shifts" title="Permalink"></a></h2><p>The expression <code>x(k-1)</code> refers to the value of <code>x</code> at the <em>previous</em> clock tick. Similarly, <code>x(k-2)</code> refers to the value of <code>x</code> at the clock tick before that. In general, <code>x(k-n)</code> refers to the value of <code>x</code> at the <code>n</code>th clock tick before the current one. As an example, the Z-domain transfer function</p><p class="math-container">\[H(z) = \dfrac{b_2 z^2 + b_1 z + b_0}{a_2 z^2 + a_1 z + a_0}\]</p><p>may thus be modeled as</p><pre><code class="language-julia hljs">@variables t y(t) [description = &quot;Output&quot;] u(t) [description = &quot;Input&quot;]
k = ShiftIndex(Clock(dt))
eqs = [
    a2 * y(k) + a1 * y(k - 1) + a0 * y(k - 2) ~ b2 * u(k) + b1 * u(k - 1) + b0 * u(k - 2)
]</code></pre><h2 id="Initial-conditions"><a class="docs-heading-anchor" href="#Initial-conditions">Initial conditions</a><a id="Initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-conditions" title="Permalink"></a></h2><p>The initial condition of discrete-time variables is defined using the <code>ShiftIndex</code> operator, for example</p><pre><code class="language-julia hljs">ODEProblem(model, [x(k-1) =&gt; 1.0], (0.0, 10.0))</code></pre><p>Note how the initial condition for discrete-time variables refer to the past, and not to the value at <span>$t=0$</span> (at <code>tspan[1]</code> to be precise). The reason is that in order to perform the discrete-time state update <span>$x(k) = f(x(k-1), t_0)$</span>, at the initial time <span>$t_0$</span>, we need <span>$x(k-1)$</span> and not <span>$x(k)$</span>.</p><p>If higher-order shifts are present, the corresponding initial conditions must be specified, e.g., the presence of the equation</p><pre><code class="language-julia hljs">x(k) = x(k - 1) + x(k - 2)</code></pre><p>requires specification of the initial condition for both <code>x(k-1)</code> and <code>x(k-2)</code>.</p><h2 id="Multiple-clocks"><a class="docs-heading-anchor" href="#Multiple-clocks">Multiple clocks</a><a id="Multiple-clocks-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-clocks" title="Permalink"></a></h2><p>Multi-rate systems are easy to model using multiple different clocks. The following set of equations is valid, and defines <em>two different discrete-time partitions</em>, each with its own clock:</p><pre><code class="language-julia hljs">yd1 ~ Sample(dt1)(y)
ud1 ~ kp * (Sample(dt1)(r) - yd1)
yd2 ~ Sample(dt2)(y)
ud2 ~ kp * (Sample(dt2)(r) - yd2)</code></pre><p><code>yd1</code> and <code>ud1</code> belong to the same clock which ticks with an interval of <code>dt1</code>, while <code>yd2</code> and <code>ud2</code> belong to a different clock which ticks with an interval of <code>dt2</code>. The two clocks are <em>not synchronized</em>, i.e., they are not <em>guaranteed</em> to tick at the same point in time, even if one tick interval is a rational multiple of the other. Mechanisms for synchronization of clocks are not yet implemented.</p><h2 id="Accessing-discrete-time-variables-in-the-solution"><a class="docs-heading-anchor" href="#Accessing-discrete-time-variables-in-the-solution">Accessing discrete-time variables in the solution</a><a id="Accessing-discrete-time-variables-in-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-discrete-time-variables-in-the-solution" title="Permalink"></a></h2><p>Discrete-time variables can be accessed with the syntax</p><pre><code class="language-julia hljs">sol[var]</code></pre><h2 id="Implementing-generic-discrete-time-components"><a class="docs-heading-anchor" href="#Implementing-generic-discrete-time-components">Implementing generic discrete-time components</a><a id="Implementing-generic-discrete-time-components-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-generic-discrete-time-components" title="Permalink"></a></h2><p>Discrete-time components can be implemented without specification of the clock or sample interval. To do this, the operator <code>SampleTime()</code> is used, it returns the sample-time interval of the associated clock. See the library of components for usage example, or this simplified example component:</p><pre><code class="language-julia hljs">@mtkmodel DiscreteDerivative begin
    @extend u, y = siso = SISO()
    @parameters begin
        k = 1, [description = &quot;Gain&quot;]
    end
    @structural_parameters begin
        Ts = SampleTime()
        z = ShiftIndex()
    end
    @equations begin
        y(z) ~ k * (u(z) - u(z - 1)) / Ts # Ts will get the value of the associated clock, determined by clock inference.
    end
end</code></pre><p>In this component, we use two structural parameters, one for the sample time and one for the shift index. By letting the sample time be a structural parameter with a default given by <code>SampleTime()</code>, the default behavior is to inherit the sample time based on the connection context (clock partition) of the component. The sample time can still be manually set in case there is no other point at which to infer the sample time, or if the user for some other reason want to override the sample time. The shift index is also a structural parameter with a default. This default leaves the clock unspecified, indicating that the clock should be inherited based on the connection context (clock partition). If the user provides a shift index with a clock specified, other components may inherit their clock from this component. The operator <code>SampleTime()</code> will in all cases return the sample time of the associated clock, no matter if this clock is explicitly specified by the user or inherited from the connection context.</p><p>In order to make components maximally generic, it is often advisable to avoid including operators like <code>Sample</code> and <code>Hold</code> at the inputs and outputs of a component, and instead let the user manually insert these operators where required. Larger components that model complete sampled-data systems may of course contain such operators internally. </p><h2 id="Linearization-of-sampled-data-systems"><a class="docs-heading-anchor" href="#Linearization-of-sampled-data-systems">Linearization of sampled-data systems</a><a id="Linearization-of-sampled-data-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Linearization-of-sampled-data-systems" title="Permalink"></a></h2><p>Linearization of discrete-time and sampled-data systems using the tools described at <a href="https://docs.sciml.ai/ModelingToolkit/dev/basics/Linearization/">Linearization of ModelingToolkit models</a> is <strong>not</strong> supported at the moment. ðŸ˜¦ </p><p>Linearization through <a href="https://help.juliahub.com/juliasimcontrol/dev/linear_analysis/#Frequency-response-analysis">frequency-response analysis (FRA) is provided in JuliaSimControl</a>. FRA amounts to simulating a system with wide-spectrum inputs and computing the linear small-signal transfer function using techniques from the field of system-identification.</p><h2 id="A-complete-example"><a class="docs-heading-anchor" href="#A-complete-example">A complete example</a><a id="A-complete-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-complete-example" title="Permalink"></a></h2><p>Below, we model a simple continuous first-order system called <code>plant</code> that is controlled using a discrete-time controller <code>controller</code>. The reference signal is filtered using a discrete-time filter <code>filt</code> before being fed to the controller.</p><pre><code class="language-julia hljs">using ModelingToolkit, Plots, OrdinaryDiffEq
using ModelingToolkit: t_nounits as t
using ModelingToolkit: D_nounits as D
dt = 0.5 # Sample interval
@variables r(t)
clock = Clock(dt)
k = ShiftIndex(clock)

function plant(; name)
    @variables x(t)=1 u(t)=0 y(t)=0
    D = Differential(t)
    eqs = [D(x) ~ -x + u
           y ~ x]
    ODESystem(eqs, t; name = name)
end

function filt(; name) # Reference filter
    @variables x(t)=0 u(t)=0 y(t)=0
    a = 1 / exp(dt)
    eqs = [x(k) ~ a * x(k - 1) + (1 - a) * u(k)
           y ~ x]
    ODESystem(eqs, t, name = name)
end

function controller(kp; name)
    @variables y(t)=0 r(t)=0 ud(t)=0 yd(t)=0
    @parameters kp = kp
    eqs = [yd ~ Sample(y)
           ud ~ kp * (r - yd)]
    ODESystem(eqs, t; name = name)
end

@named f = filt()
@named c = controller(1)
@named p = plant()

connections = [r ~ (t &gt;= 5)        # reference signal
               f.u ~ r             # reference to filter input
               f.y ~ c.r           # filtered reference to controller reference
               Hold(c.ud) ~ p.u    # controller output to plant input (zero-order-hold)
               p.y ~ c.y]          # plant output to controller feedback

@named cl = ODESystem(connections, t, systems = [f, c, p])
cl = complete(cl)</code></pre><p class="math-container">\[ \begin{align}
r\left( t \right) &amp;= t \geq 5 \\
f_{+}u\left( t \right) &amp;= r\left( t \right) \\
f_{+}y\left( t \right) &amp;= c_{+}r\left( t \right) \\
\mathrm{Hold()}\left( c_{+}ud\left( t \right) \right) &amp;= p_{+}u\left( t \right) \\
p_{+}y\left( t \right) &amp;= c_{+}y\left( t \right) \\
f_{+}x\left( t \right) &amp;= 0.39347 f_{+}u\left( t \right) + 0.60653 \mathrm{Shift(t, -1)}\left( f_{+}x\left( t \right) \right) \\
f_{+}y\left( t \right) &amp;= f_{+}x\left( t \right) \\
c_{+}yd\left( t \right) &amp;= \mathrm{Sample(InferredTimeDomain::InferredDiscrete)}\left( c_{+}y\left( t \right) \right) \\
c_{+}ud\left( t \right) &amp;= c_{+}kp \left(  - c_{+}yd\left( t \right) + c_{+}r\left( t \right) \right) \\
\frac{\mathrm{d} p_{+}x\left( t \right)}{\mathrm{d}t} &amp;= p_{+}u\left( t \right) - p_{+}x\left( t \right) \\
p_{+}y\left( t \right) &amp;= p_{+}x\left( t \right)
\end{align}
 \]</p><p>We can now simulate the system. JuliaSimCompiler is required to simulate hybrid continuous/discrete systems, we thus convert the system to an <code>JuliaSimCompiler.IRSystem</code> before calling <code>structural_simplify</code></p><pre><code class="language-julia hljs">using JuliaSimCompiler, Plots
ssys = structural_simplify(IRSystem(cl))

prob = ODEProblem(ssys, [
    cl.f.x(k-1) =&gt; 0,
], (0,15))

sol = solve(prob, Tsit5())
plot(sol, idxs=[cl.p.x, cl.c.ud], layout=(2,1))</code></pre><img src="c71105c9.svg" alt="Example block output"/><p>Note how the initial condition provided above refers to the value of <code>f.x</code> at a past time point. If we had not provided this initial condition, we would have gotten an error like this</p><pre><code class="language-julia hljs">try
    ODEProblem(ssys, [], (0,15))
catch err
    return err
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ErrorException(&quot;The initial condition for parameter shift(fâ‚Šx(0.5), -1, false, 0.5) isn&#39;t provided.&quot;)</code></pre><p>The error message indicates that the -1 shift for <code>f.x</code> is not provided. The number <code>0.5</code> appearing in the error message is the period of the clock associated the variable for which an initial condition is missing <code>f.x</code>.</p><h2 id="Further-reading"><a class="docs-heading-anchor" href="#Further-reading">Further reading</a><a id="Further-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading" title="Permalink"></a></h2><ul><li><a href="https://juliacontrol.github.io/ControlSystems.jl/stable/examples/zoh/">Analysis of linear sampled-data systems using ControlSystems.jl</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">Â« Home</a><a class="docs-footer-nextpage" href="../noise/">Noise and measurement corruption Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 6 September 2024 04:54">Friday 6 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
