<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Noise and measurement corruption · ModelingToolkitSampledData.jl</title><meta name="title" content="Noise and measurement corruption · ModelingToolkitSampledData.jl"/><meta property="og:title" content="Noise and measurement corruption · ModelingToolkitSampledData.jl"/><meta property="twitter:title" content="Noise and measurement corruption · ModelingToolkitSampledData.jl"/><meta name="description" content="Documentation for ModelingToolkitSampledData.jl."/><meta property="og:description" content="Documentation for ModelingToolkitSampledData.jl."/><meta property="twitter:description" content="Documentation for ModelingToolkitSampledData.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelingToolkitSampledData.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../SampledData/">Getting started with Sampled-Data Systems</a></li><li class="is-active"><a class="tocitem" href>Noise and measurement corruption</a><ul class="internal"><li><a class="tocitem" href="#Example:-Noise"><span>Example: Noise</span></a></li><li><a class="tocitem" href="#Noise-filtering"><span>Noise filtering</span></a></li><li><a class="tocitem" href="#Colored-noise"><span>Colored noise</span></a></li><li><a class="tocitem" href="#Internal-details"><span>Internal details</span></a></li><li><a class="tocitem" href="#Quantization"><span>Quantization</span></a></li><li><a class="tocitem" href="#Sampling-with-AD-effects"><span>Sampling with AD effects</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/dc_motor_pi/">Controlled DC motor</a></li><li><a class="tocitem" href="../../examples/onoffcontroller/">On-off controller</a></li><li><a class="tocitem" href="../../examples/sliding_mode_control/">Sliding-mode control</a></li></ul></li><li><a class="tocitem" href="../../blocks/">Library API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Noise and measurement corruption</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Noise and measurement corruption</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaComputing/ModelingToolkitSampledData.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Measurement-noise-and-corruption"><a class="docs-heading-anchor" href="#Measurement-noise-and-corruption">Measurement noise and corruption</a><a id="Measurement-noise-and-corruption-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-noise-and-corruption" title="Permalink"></a></h1><p>Measurement noise is practically always present in signals originating from real-world sensors. In a sampled-data system, analyzing the influence of measurement noise using simulation is relatively straight forward. Below, we add Gaussian white noise to the speed sensor signal in the DC-motor example from <a href="../../examples/dc_motor_pi/#DC-Motor-with-PI-controller">DC Motor with PI-controller</a>. The noise is added using the <a href="../../blocks/#ModelingToolkitSampledData.NormalNoise"><code>NormalNoise</code></a> block.</p><p>This block has two modes of operation</p><ol><li>If <code>additive = false</code> (default), the block has the connector <code>output</code> only, and this output is the noise signal.</li><li>If <code>additive = true</code>, the block has the connectors <code>input</code> and <code>output</code>, and the output is the sum of the input and the noise signal, i.e., the noise is <em>added</em> to the input signal. This mode makes it convenient to add noise to a signal in a sampled-data system.</li></ol><h2 id="Example:-Noise"><a class="docs-heading-anchor" href="#Example:-Noise">Example: Noise</a><a id="Example:-Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Noise" title="Permalink"></a></h2><p>This example is a continuation of the DC-motor example from <a href="../../examples/dc_motor_pi/#DC-Motor-with-PI-controller">DC Motor with PI-controller</a>. We add Gaussian white noise with <span>$σ^2 = 0.1^2$</span> to the speed sensor signal.</p><pre><code class="language-julia hljs">using ModelingToolkit
using ModelingToolkit: t_nounits as t
using ModelingToolkitStandardLibrary.Electrical
using ModelingToolkitStandardLibrary.Mechanical.Rotational
using ModelingToolkitStandardLibrary.Blocks
using ModelingToolkitSampledData
using JuliaSimCompiler
using OrdinaryDiffEq
using Plots

R = 0.5 # [Ohm] armature resistance
L = 4.5e-3 # [H] armature inductance
k = 0.5 # [N.m/A] motor constant
J = 0.02 # [kg.m²] inertia
f = 0.01 # [N.m.s/rad] friction factor
tau_L_step = -0.3 # [N.m] amplitude of the load torque step

z = ShiftIndex()

@mtkmodel NoisyClosedLoop begin
    @components begin
        ground = Ground()
        source = Voltage()
        ref = Blocks.Step(height = 1, start_time = 0, smooth = false)
        sampler = Sampler(dt = 0.002)
        noise = NormalNoise(sigma = 0.1, additive = true)
        pi_controller = DiscretePIDStandard(
            K = 1, Ti = 0.035, u_max = 10, with_D = false)
        zoh = ZeroOrderHold()
        R1 = Resistor(R = R)
        L1 = Inductor(L = L)
        emf = EMF(k = k)
        fixed = Fixed()
        load = Torque()
        load_step = Blocks.Step(height = tau_L_step, start_time = 1.3)
        inertia = Inertia(J = J)
        friction = Damper(d = f)
        speed_sensor = SpeedSensor()
        angle_sensor = AngleSensor()
    end

    @equations begin
        connect(fixed.flange, emf.support, friction.flange_b)
        connect(emf.flange, friction.flange_a, inertia.flange_a)
        connect(inertia.flange_b, load.flange)
        connect(inertia.flange_b, speed_sensor.flange, angle_sensor.flange)
        connect(load_step.output, load.tau)
        connect(ref.output, pi_controller.reference)
        connect(speed_sensor.w, sampler.input)
        connect(sampler.output, noise.input)
        connect(noise.output, pi_controller.measurement)
        connect(pi_controller.ctr_output, zoh.input)
        connect(zoh.output, source.V)
        connect(source.p, R1.p)
        connect(R1.n, L1.p)
        connect(L1.n, emf.p)
        connect(emf.n, source.n, ground.g)
    end
end


@named noisy_model = NoisyClosedLoop()
noisy_model = complete(noisy_model)
ssys = structural_simplify(IRSystem(noisy_model)) # Conversion to an IRSystem from JuliaSimCompiler is required for sampled-data systems

noise_prob = ODEProblem(ssys, [unknowns(noisy_model) .=&gt; 0.0; noisy_model.pi_controller.I(z-1) =&gt; 0; noisy_model.pi_controller.eI(z-1) =&gt; 0; noisy_model.noise.y(z-1) =&gt; 0], (0, 2.0))
noise_sol = solve(noise_prob, Tsit5())

figy = plot(noise_sol, idxs=noisy_model.noise.y, label = &quot;Measured speed&quot;, )
plot!(noise_sol, idxs=noisy_model.inertia.w, ylabel = &quot;Angular Vel. [rad/s]&quot;,
    label = &quot;Actual speed&quot;, legend=:bottomleft, dpi=600, l=(2, :blue))
figu = plot(noise_sol, idxs=noisy_model.source.V.u, label = &quot;Control signal [V]&quot;, )
plot(figy, figu, plot_title = &quot;DC Motor with Discrete-time Speed Controller&quot;)</code></pre><img src="16b942f9.svg" alt="Example block output"/><h2 id="Noise-filtering"><a class="docs-heading-anchor" href="#Noise-filtering">Noise filtering</a><a id="Noise-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-filtering" title="Permalink"></a></h2><p>You may, e.g.</p><ul><li>Use <a href="../../blocks/#ModelingToolkitSampledData.ExponentialFilter"><code>ExponentialFilter</code></a> to add exponential filtering using <code>y(k) ~ (1-a)y(k-1) + a*u(k)</code>, where <code>a</code> is the filter coefficient and <code>u</code> is the signal to be filtered.</li></ul><p>No discrete-time filter components are available yet. You may, e.g.</p><ul><li>Use <a href="../../blocks/#ModelingToolkitSampledData.MovingAverageFilter"><code>MovingAverageFilter</code></a> to add moving average filtering according to <code>y(k) ~ 1/N * sum(u(k-i) for i=0:N-1)</code>, where <code>N</code> is the number of samples to average over.</li></ul><h2 id="Colored-noise"><a class="docs-heading-anchor" href="#Colored-noise">Colored noise</a><a id="Colored-noise-1"></a><a class="docs-heading-anchor-permalink" href="#Colored-noise" title="Permalink"></a></h2><p>Colored noise can be achieved by filtering white noise through a filter with the desired spectrum. No components are available for this yet.</p><h2 id="Internal-details"><a class="docs-heading-anchor" href="#Internal-details">Internal details</a><a id="Internal-details-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-details" title="Permalink"></a></h2><p>Internally, a random number generator from <a href="https://github.com/JuliaRandom/StableRNGs.jl">StableRNGs.jl</a> is used to produce reproducible streams of random numbers. Each draw of a random number is seeded by <code>hash(t, hash(seed))</code>, where <code>seed</code> is a parameter in the noise source component, and <code>t</code> is the current simulation time. This ensures that</p><ol><li>The user can alter the stream of random numbers with <code>seed</code>.</li><li>Multiple calls to the random number generator at the same time step all return the same number.</li></ol><h2 id="Quantization"><a class="docs-heading-anchor" href="#Quantization">Quantization</a><a id="Quantization-1"></a><a class="docs-heading-anchor-permalink" href="#Quantization" title="Permalink"></a></h2><p>A signal may be quantized to a fixed number of levels (e.g., 8-bit) using the <a href="#Quantization"><code>Quantization</code></a> block. This may be used to simulate, e.g., the quantization that occurs in a AD converter. Below, we have a simple example where a sine wave is quantized to 2 bits (4 levels), limited between -1 and 1:</p><pre><code class="language-julia hljs">using ModelingToolkit, ModelingToolkitSampledData, OrdinaryDiffEq, Plots
using ModelingToolkit: t_nounits as t, D_nounits as D
using ModelingToolkitStandardLibrary.Blocks
using JuliaSimCompiler
z = ShiftIndex(Clock(0.1))
@mtkmodel QuantizationModel begin
    @components begin
        input = Sine(amplitude=1.5, frequency=1)
        quant = Quantization(; z, bits=2, y_min = -1, y_max = 1)
    end
    @variables begin
        x(t) = 0 # Dummy variable to work around a bug for models without continuous-time state
    end
    @equations begin
        connect(input.output, quant.input)
        D(x) ~ 0 # Dummy equation
        # D(x) ~ Hold(quant.y) # Dummy equation
    end
end
@named m = QuantizationModel()
m = complete(m)
ssys = structural_simplify(IRSystem(m))
prob = ODEProblem(ssys, [], (0.0, 2.0))
sol = solve(prob, Tsit5())
plot(sol, idxs=m.input.output.u)
plot!(sol, idxs=m.quant.y, label=&quot;Quantized output&quot;)</code></pre><img src="e2a77796.svg" alt="Example block output"/><h3 id="Different-quantization-modes"><a class="docs-heading-anchor" href="#Different-quantization-modes">Different quantization modes</a><a id="Different-quantization-modes-1"></a><a class="docs-heading-anchor-permalink" href="#Different-quantization-modes" title="Permalink"></a></h3><p>With the default option <code>midrise = true</code>, the output of the quantizer is always between <code>y_min</code> and <code>y_max</code> inclusive, and the number of distinct levels it can take is <code>2^bits</code>. The possible values are given by</p><pre><code class="language-julia hljs">bits = 2; y_min = -1; y_max = 1
collect(range(y_min, stop=y_max, length=2^bits))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 -1.0
 -0.3333333333333333
  0.3333333333333333
  1.0</code></pre><p>Notably, these possible levels <em>do not include 0</em>. If <code>midrise = false</code>, a mid-tread quantizer is used instead. The two options are visualized below:</p><pre><code class="language-julia hljs">y_min = -1; y_max = 1; bits = 2
u = y_min:0.01:y_max
y_mr = ModelingToolkitSampledData.quantize_midrise.(u, bits, y_min, y_max)
y_mt = ModelingToolkitSampledData.quantize_midtread.(u, bits, y_min, y_max)
plot(u, [y_mr y_mt], label=[&quot;Midrise&quot; &quot;Midtread&quot;], xlabel=&quot;Input&quot;, ylabel=&quot;Output&quot;, framestyle=:zerolines, l=2, seriestype=:step)</code></pre><img src="1a39b293.svg" alt="Example block output"/><p>Note how the default mid-rise quantizer mode has a rise at the middle of the interval, while the mid-tread mode has a flat region (a tread) centered around the middle of the interval.</p><p>The default option <code>midrise = true</code> includes both end points as possible output values, while <code>midrise = false</code> does not include the upper limit.</p><h2 id="Sampling-with-AD-effects"><a class="docs-heading-anchor" href="#Sampling-with-AD-effects">Sampling with AD effects</a><a id="Sampling-with-AD-effects-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-with-AD-effects" title="Permalink"></a></h2><p>The block <a href="../../blocks/#ModelingToolkitSampledData.SampleWithADEffects"><code>SampleWithADEffects</code></a> combines an ideal <a href="../../blocks/#ModelingToolkitSampledData.Sampler"><code>Sampler</code></a>, a <a href="../../blocks/#ModelingToolkitSampledData.NormalNoise">`NormalNoise</a> and a <a href="#Quantization"><code>Quantization</code></a> block to simulate the undesirable but practically occurring effects of sampling, noise and quantization in an AD converter. The block has the connectors <code>input</code> and <code>output</code>, where the input is the continuous-time signal to be sampled, and the output is the quantized, noisy signal. Example:</p><pre><code class="language-julia hljs">@mtkmodel PracticalSamplerModel begin
    @components begin
        input = Sine(amplitude=1.2, frequency=1, smooth=false)
        sampling = SampleWithADEffects(; dt=0.03, bits=3, y_min = -1, y_max = 1, sigma = 0.1, noisy = true, quantized=true, midrise=true)
    end
    @variables begin
        x(t) = 0 # Dummy variable to work around a bug for models without continuous-time state
    end
    @equations begin
        connect(input.output, sampling.input)
        D(x) ~ Hold(sampling.y) # Dummy equation
    end
end
@named m = PracticalSamplerModel()
m = complete(m)
ssys = structural_simplify(IRSystem(m))
prob = ODEProblem(ssys, [m.sampling.noise.y(z-1) =&gt; 0], (0.0, 2.0))
sol = solve(prob, Tsit5())
plot(sol, idxs=m.input.output.u)
plot!(sol, idxs=m.sampling.y, label=&quot;AD converted output&quot;)</code></pre><img src="fc3daa2b.svg" alt="Example block output"/><p>Both quantization and noise addition are optional and turned off by default. In the example above, we turn them on with keywords <code>noisy = true</code> and <code>quantized = true</code>. The noise is Gaussian white noise with standard deviation <code>sigma</code>, and the quantization is a 3-bit midrise quantizer (8 output levels) with limits <code>y_min</code> and <code>y_max</code>. Limits have to be provided when quantization is used. The <code>dt</code> parameter is the sampling time, if left unspecified, it will be inferred from context.</p><p>Things to notice in the plot:</p><ul><li>The sampled signal is saturated at the quantization limits ±1.</li><li>The noise is added to the signal before quantization, which means that the sampled signal has <span>$2^\text{bits}$</span> distinct output levels only.</li><li>0 is not a possible output value. In situations where 0 is an important value (such as in the presence of integration of a quantized value that is expected to be close to 0), the mid-tread quantizer should be used instead by passing <code>midrise = false</code>.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../SampledData/">« Getting started with Sampled-Data Systems</a><a class="docs-footer-nextpage" href="../../examples/dc_motor_pi/">Controlled DC motor »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 6 September 2024 08:38">Friday 6 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
